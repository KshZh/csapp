计算机补码运算背后的数学原理是什么？ - 猪鼻蛇的回答 - 知乎
https://www.zhihu.com/question/30395946/answer/783708748

模运算系统：
$$
-x \equiv 2^n-x \space (mod \space 2^n)
$$
时钟是一个模12运算系统，时针指向4点，要拨到11点，可以`4+7=11`，也可以`4-5=4+(12-5)=11`。

求负数的补码，可以先求其相反数（正数）的补码，**注意包括为0的符号位**，然后对这一bit序列取反加一得到。

当然，以上是最常用，自然求正数的补码也可以这么做，但几乎没人这么做就是了。

以上两者求法，归结为：求x的相反数的补码只需对x的补码取反加一。

对这一做法的解释如下（注意x本身也可以表示一个负数，而-x则表示一个正数）：
$$
x = \sum_{i=0}^{n-1}a_i\cdot2^i \\ 其中正数的符号位为0\\

-x = 2^n - x = 2^n - (\sum_{i=0}^{n-1}a_i\cdot2^i) = 1 + (\sum_{i=0}^{n-1}2^i) - (\sum_{i=0}^{n-1}a_i\cdot2^i) = 1 + (\sum_{i=0}^{n-1}(1-a_i)\cdot2^i) \\ 注意符号位也要取反
$$
显然有：
$$
a - b \equiv a + (2^n - b) \space (mod \space 2^n)\\
a \cdot (-b) \equiv a \cdot (2^n - b) \space (mod \space 2^n)
$$
由此可以在模运算系统中，减去一个数只需要加上这个数的相反数的补码即可，而求一个数的相反数的补码是相对容易的，由此就可以不用考虑减法。

补码定义中将最高位的权视作负权的解释（这个看不明白）：
$$
0 \cdot -2^{(n-1)} + (\sum_{i=0}^{n-2}a_i\cdot2^i) \equiv 0 \cdot 2^{(n-1)} + (\sum_{i=0}^{n-2}a_i\cdot2^i)\\
1\cdot-2^{(n-1)} + (\sum_{i=0}^{n-2}a_i\cdot2^i) \equiv 2^n-2^{(n-1)} + (\sum_{i=0}^{n-2}a_i\cdot2^i) \equiv 1\cdot2^{(n-1)} + (\sum_{i=0}^{n-2}a_i\cdot2^i)
$$
